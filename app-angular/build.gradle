import java.util.concurrent.atomic.AtomicInteger
import org.apache.tools.ant.taskdefs.condition.Os
import com.github.eerohele.SaxonXsltTask

plugins {
  id("com.github.eerohele.saxon-gradle") version "0.7.0"
}

def translationsOutPath = "${rootDir.absolutePath}/app-angular/src/assets/locale/"
Map<String, Map<String,String>> languageMapOfMaps = new HashMap<>()

//Prepare dynamic task to generate XLF for each language locale
def generateTranslationLocales = []
new File("${rootDir.absolutePath}/core/locale/main").eachDir{File localeDir ->

  def langCode = ""
  if(localeDir.name.contains("-")) {
    langCode = localeDir.name.substring(localeDir.name.indexOf("-") + 1)
  }else {
    langCode = "en"
  }
  def taskName = "generateLocale_${langCode}"

  task "${taskName}" (type: SaxonXsltTask){
    stylesheet project.file("locale-transform.xsl")
    input file(project.file("src/assets/locale/messages.xlf"))
    output file(project.file("src/assets/locale/messages.${langCode}.xlf"))
    parameters(
      strings_src: "${localeDir.absolutePath}/strings_ui.xml)"
    )
  }
  generateTranslationLocales.push(taskName)
}


/**
 * Generate locale json file whic maps code to actual string
 */
task prepareWebJsonLocales{
  File outFile = null
  if(!file(translationsOutPath).exists()){
    file(translationsOutPath).mkdirs()
  }

  Map<String, Integer> messageIds = new HashMap<>()
  AtomicInteger messageIdGenerator = new AtomicInteger(2000)
  def localeCode = "en"
  rootProject.fileTree(dir: "core/locale/main").each() { File file ->

    Map<String, String> idToTranslationMap = new HashMap<>()

    def separator = "/"
    if(Os.isFamily(Os.FAMILY_WINDOWS)){
      separator = "\\\\"
    }

    if(file.absolutePath.split("-").size() > 1){
      localeCode = file.absolutePath.split("-")[1].split(separator)[0]
    }
    File tempFile = project.file("${translationsOutPath}locale.${localeCode}.json")
    if(tempFile.exists()){
      tempFile.delete()
    }
    outFile = tempFile
    if(!outFile.getParentFile().exists()) {
      outFile.getParentFile().mkdirs()
    }

    def xmlDoc = new XmlSlurper().parseText(file.getText("UTF-8"))
    def counter = 0
    def terminator = ","
    def fileContent = "{\n\n"
    def value = 0
    xmlDoc.string.each() { str ->
      String msgName = str.@name
      String msgValue = str
      if (!messageIds.containsKey(msgName)) {
        if (str.attributes().get("value") != null) {
          value = new Integer(str.attributes().get("value"))
        } else {
          value = new Integer(messageIdGenerator.getAndIncrement())
        }
        messageIds.put(msgName, value as Integer)
      }else{
        value = messageIds.get(msgName)
      }

      if(counter == xmlDoc.string.size() -1){
        terminator = ""
      }

      msgValue = msgValue.replace("\n","").replace("\\", "\\\\").replace("\"","\\\"")
      fileContent <<= '    "' + String.valueOf(value) + '" : "'+msgValue+'"'+"${terminator}\n\n"

      idToTranslationMap.put(msgName,msgValue)
      languageMapOfMaps.put(localeCode, idToTranslationMap)

      counter++
    }

    fileContent <<=  '}'
    fileContent <<= ""
    outFile << fileContent
  }

}

/**
 * Generate default XLF file to be used for other translation
 */
task generateDefaultLocaleXlf(type: Exec){
  commandLine 'npm', 'run','um-translate'
}
generateDefaultLocaleXlf.dependsOn(prepareWebJsonLocales)
generateDefaultLocaleXlf.finalizedBy(generateTranslationLocales)

/**
 * Generate other locale XLF files based on default translation
 */
task generateOtherXliff{}
generateOtherXliff.dependsOn(generateDefaultLocaleXlf)


